<style>
	body {
		overflow: hidden;
	}
</style>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

<script src='./three.min.js'></script>
<script src="./TrackballControls.js"></script>
<script src="./Detector.js"></script>


<style>
#tdw {
		width:100%;
		height:100%;
	}
</style>
		

<div id="tdw"></div>		
	
<script>

	if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
	var container;
	var camera, controls, scene, renderer;
	var cross;
	var object3D;
	var time = 0;
	
	var hall =  15;

	init();


			
	function init( ) {
		container = document.getElementById("tdw");
	
		camera = new THREE.PerspectiveCamera( 80, container.offsetWidth/container.offsetHeight, 0.01, 1e10 );  //distance , 
		camera.position.set( 10, 10, 10);		
		camera.up.set( 0, 0, 1 );
		camera.lookAt( 0,0, 50);

		controls = new THREE.TrackballControls( camera );
		controls.dynamicDampingFactor = 0.5;
		scene = new THREE.Scene();
		scene.add( camera );


		makeArrowGrid(1,1,15);
		showStructure(object3D, structure(1,1,15));
		
		requestAnimationFrame( animate )		
		

		renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize(container.offsetWidth, container.offsetHeight );
		renderer.setClearColor( 0xffffff, 1);
		container.appendChild( renderer.domElement );
		
		// axes arrows
		arrow = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 5, 0xff0000, 0.5, 0.4);
		scene.add(arrow);
		arrow = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), 5, 0x00ff00, 0.5, 0.4);
		scene.add(arrow);
		arrow = new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,0), 5, 0x0000ff, 0.5, 0.4);
		scene.add(arrow);





	}
	
	function circle(r, color){
		var lineGeometry = new THREE.Geometry();
		var vertArray = lineGeometry.vertices;
		for (var i=0; i < 2*Math.PI; i+=0.01) {
			vertArray.push(new THREE.Vector3(r * Math.cos(i), r * Math.sin(i), 0));
		}
		lineGeometry.computeLineDistances();
		var lineMaterial = new THREE.LineBasicMaterial({ color: color });
		var circle = new THREE.Line(lineGeometry, lineMaterial);

		return circle;
	}
	

	
	
	function structure(xmax, ymax, zmax){
		vectors = Array();
		wavelength = 5; // in number of spins
		for (z = 0; z < zmax; z++) { 
		for (y = 0; y < ymax; y++) { 
		for (x = 0; x < xmax; x++) { 
			
			
			var v0 = new THREE.Vector3( 0, 0, 1 );
			
			// dynamics
			v0.applyAxisAngle( new THREE.Vector3( 1, 0, 0 ), Math.PI/180*hall );		// rotate about x by hall angle
			var precession = time + ( 40 * z);
			v0.applyAxisAngle( new THREE.Vector3( 0, 0, 1 ), Math.PI/180*precession )	// rotate about z by precession angle
			

				
			// conical structure
			v0.applyAxisAngle( new THREE.Vector3( 1, 0, 0 ), Math.PI/2 )	// rotate about x by 90 degrees
			var conical = 40 * z;
			v0.applyAxisAngle( new THREE.Vector3( 0, 0, 1 ), Math.PI/180*conical )		// rotate about z by conical precession
			
			
			vectors = vectors.concat(v0);

		}}}
		
		return vectors;
	}
		
		
		
		
		
		
		
		
	function makeArrowGrid(xmax, ymax, zmax){
		object3D = new THREE.Object3D();
		for (z = 0; z < zmax; z++) { 
		for (y = 0; y < ymax; y++) { 
		for (x = 0; x < xmax; x++) { 
			var arrow = new THREE.ArrowHelper(new THREE.Vector3(0,0,0), new THREE.Vector3( x,y,z), 1, 0xffffff, 0.5, 0.4);
			object3D.add(arrow);
			
			circ = circle(1, 0xaaffaa);
			circ.position.set( 0, 0, z );
			scene.add(circ);
			
			
			circ = circle(Math.sin(Math.PI/180*hall), 0xffaaaa);
			var conical = 40 * z;
			rotation = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2);
			circ.applyMatrix(rotation);
			rotation = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), Math.PI/180*conical);
			circ.applyMatrix(rotation);
			length = Math.cos(Math.PI/180*hall);
			transformation = new THREE.Matrix4().makeTranslation(length*Math.sin(Math.PI/180*conical), -length*Math.cos( Math.PI/180*conical), z);
			
	
			circ.applyMatrix(transformation);
			
			scene.add(circ);
			

			
		}}}
		scene.add(object3D);
		
		
		
		
	}

	function showStructure(object, omf) {
		for (i = 0; i < object3D.children.length; i++ ) { 
			var color = new THREE.Color( 0x000000 );
			//var xy = new THREE.Vector2(omf[i*3],omf[i*3+1]);
			//var hue = Math.atan2(xy.y, xy.x)/(2*Math.PI);
			//color.setHSL(hue,1,0.5);
			
			object3D.children[i].setColor(color);
			object3D.children[i].setDirection(omf[i]);
		}
	}
		
	
		
	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
		controls.handleResize();
	}
	
	
	function animate() {
	//console.log (object3D.rotation.x + " " + object3D.rotation.y + " " + object3D.rotation.z);
	//console.log (camera.position.x + " " + camera.position.y + " " + camera.position.z + " " + camera.rotation.x + " " + camera.rotation.y + " " + camera.rotation.z);
		//object3D.rotation.z += 0.001;
		//object3D.rotation.z += 0.01;
		
		time += 1;
		showStructure(object3D, structure(1,1,20));
		
		requestAnimationFrame( animate );
		controls.update();
		renderer.render( scene, camera );
	}
</script>