<meta charset="utf-8">
<!--<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">-->

<style>
#structure {
		width:100%;
		height:680px;
	}
	
.container-fluid {
  height: 100vh;  
}
</style>
		
		
<div ng-app="myApp" ng-controller="mainController" >
<div class="container-fluid">
	<h1> CSO DFMR </h1>
	
	
	<div class="row" height=500px>
		<div class="col-sm-6">

			<div class="row">
				<div class="col-sm-3 text-right"><b>Tilt angle:</b></div> 
				<div class="col-sm-9"> <rzslider rz-slider-model="tilt" rz-slider-options="{ceil:90}"></rzslider> </div>
			</div>	
			
			
			<div class="row">
				<div class="col-sm-3 text-right"><b>Zeeman angle:</b></div> 
				<div class="col-sm-9"> <rzslider rz-slider-model="zeeman" rz-slider-options="{ceil:90}"></rzslider> </div>
			</div>	

			<div class="row">
				<div class="col-sm-3 text-right"><b> Conical periods:</b></div> 
				<div class="col-sm-9"> <rzslider rz-slider-model="conicalPeriods" rz-slider-options="{ceil:8, floor:-8}"></rzslider> </div>
			</div>
			
			
			
			<div class="row">
				<div class="col-sm-3 text-right"><b> Phase periods:</b></div> 
				<div class="col-sm-9"> <rzslider rz-slider-model="phasePeriods" rz-slider-options="{ceil:8, floor:-8}"></rzslider> </div>
			</div>
			
			
			
			<div class="row">
				<div class="col-sm-3 text-right"><b> Cone angle:</b></div> 
				<div class="col-sm-9"> <rzslider rz-slider-model="hall" rz-slider-options="{ceil:90}"></rzslider> </div>
			</div>
			
			<div class="row">
				<div class="col-sm-3 text-right"><b> th:</b></div> 
				<div class="col-sm-9"> <rzslider rz-slider-model="th" rz-slider-options="{ceil:90}"></rzslider> </div>
			</div>
			<div class="row">
				<div class="col-sm-3 text-right"><b> tth:</b></div> 
				<div class="col-sm-9"> <rzslider rz-slider-model="tth" rz-slider-options="{ceil:90}"></rzslider> </div>
			</div>
			
			<div class="row">
				<div class="col-sm-3 text-right"><b> idx:</b></div> 
				<div class="col-sm-9"> <rzslider rz-slider-model="idx" rz-slider-options="{ceil:16}"></rzslider> </div>
			</div>
			
			
			

			
			<div class="row">
				<div class="col-sm-12"><h2> Intensity </h2> </div> 
				<div colormap x="delay" y="laa" model="laaDelayGrid"> </div>
			</div>
			
			<div class="row">
				<div class="col-sm-12"><h2> FFT </h2> </div> 
				<div graph-plot model="fftStructure[(timeStep/10 | number : 0) % 36 ][0]"> </div>
				<br>
				<div graph-plot model="fftStructure[(timeStep/10 | number : 0) % 36][1]"> </div>
				<br>
				<div graph-plot model="fftStructure[(timeStep/10 | number : 0) % 36][2]"> </div>
			</div>
			
			
		</div>
	

		<div class="col-sm-6">
			<div class="row">
				<div class="col-sm-3 text-right"><b> Speed:</b></div> 
				<div class="col-sm-9"> <rzslider rz-slider-model="speed" rz-slider-options="{ceil:10}"></rzslider> </div>
			</div>
			
			<div class="row">
				<div class="col-sm-3 text-right"><b> Time step:</b></div> 
				<div class="col-sm-9"> <rzslider rz-slider-model="timeStep" rz-slider-options="{ceil:360}"></rzslider> </div>
			</div>
			
			<div class="row">
				<div class="col-sm-12">
					<div id="structure" class="border"></div>		
				</div>
			</div>
		</div>		
	</div>
			

	
</div>
</div>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/angularjs-slider/7.0.0/rzslider.min.css">



<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.4/angular.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/angularjs-slider/7.0.0/rzslider.min.js"></script>



<script src="https://d3js.org/d3.v5.min.js"></script>

<script src='./three.min.js'></script>
<script src="./TrackballControls.js"></script>
<script src="./OrbitControls.js"></script>
<script src="./Detector.js"></script>
<script src="./fft.js"></script>


<script>
var app = angular.module('myApp', ['rzSlider']);
</script>
<script src="./graphDirective.js"></script>
<script src="./colormapDirective.js"></script>




<script>

app.controller('mainController', function($scope) {
	$scope.timeStep = 0;
	$scope.speed = 4;

	$scope.gridSize = [16,1,1];
	$scope.circlesGridSize = [16,1,1];
	
	// spin structure params
	$scope.tilt = 90;
	$scope.zeeman = 0;
	$scope.conicalPeriods = 2; // in z direction
	$scope.phasePeriods = 0;
	$scope.hall = 10;

	// dfmr params
	$scope.th = 10;
	$scope.tth = 20;
	$scope.ki = new THREE.Vector3(Math.cos($scope.th* Math.PI / 180) , 0, Math.sin($scope.th* Math.PI / 180));
	$scope.ks = new THREE.Vector3(Math.cos($scope.tth* Math.PI / 180) , 0,-Math.sin($scope.tth* Math.PI / 180));
	$scope.P = PS([0])[0];
	
	$scope.idx = 10;
	$scope.laa = [0,15,30,45,60,75,90,105,120,135,150,165];
	$scope.delay = []; //[0,15,30,45,60,75,90,105,120,135,150,165,180,195,210,225,240,255,270,285,300,315,330,345];

	for (i = 0; i < 360; i=i+10) {
		$scope.delay.push(i);
	} 

	$scope.laaDelayGrid = [];

	$scope.spinStructure =  [];
	$scope.fftStructure = [];

	$scope.$watch('tilt', function (newVal) {
		drawCircles();
		processStructure();
		$scope.laaDelayGrid = calculateLaaDelay($scope.laa, $scope.delay, $scope.idx);
    }, true);
	
	$scope.$watch('zeeman', function (newVal) {
		drawCircles();
		processStructure();
		$scope.laaDelayGrid = calculateLaaDelay($scope.laa, $scope.delay, $scope.idx);
    }, true);
	
	$scope.$watch('hall', function (newVal) {
		drawCircles();
		processStructure();
		$scope.laaDelayGrid = calculateLaaDelay($scope.laa, $scope.delay, $scope.idx);
    }, true);
	
	$scope.$watch('conicalPeriods', function (newVal) {
		drawCircles();
		processStructure();
		$scope.laaDelayGrid = calculateLaaDelay($scope.laa, $scope.delay, $scope.idx);
    }, true);
	
	$scope.$watch('phasePeriods', function (newVal) {
		processStructure();
		$scope.laaDelayGrid = calculateLaaDelay($scope.laa, $scope.delay, $scope.idx);
    }, true);
	
	



	$scope.$watch('th', function (newVal) {
		$scope.ki = new THREE.Vector3(Math.cos($scope.th* Math.PI / 180) , 0, Math.sin($scope.th* Math.PI / 180));
		$scope.ks = new THREE.Vector3(Math.cos($scope.tth* Math.PI / 180) , 0,-Math.sin($scope.tth* Math.PI / 180));
		$scope.laaDelayGrid = calculateLaaDelay($scope.laa, $scope.delay, $scope.idx);
    }, true);
	
	$scope.$watch('tth', function (newVal) {
		$scope.ki = new THREE.Vector3(Math.cos($scope.th* Math.PI / 180) , 0, Math.sin($scope.th* Math.PI / 180));
		$scope.ks = new THREE.Vector3(Math.cos($scope.tth* Math.PI / 180) , 0,-Math.sin($scope.tth* Math.PI / 180));
		$scope.laaDelayGrid = calculateLaaDelay($scope.laa, $scope.delay, $scope.idx);
    }, true);
	
	$scope.$watch('idx', function (newVal) {
		$scope.laaDelayGrid = calculateLaaDelay($scope.laa, $scope.delay, $scope.idx);
	}, true);
	


	
	
	
	var tick = function() {
		$scope.timeStep = ($scope.timeStep + $scope.speed) % 360;

		showStructure(arrows, $scope.spinStructure[parseInt($scope.timeStep/10)]);
		
		//requestAnimationFrame( animate );
		controls.update();
		renderer.render( scene, camera );
		
		$scope.$applyAsync();
	}

	setInterval(tick, 50);
	

	
	
	//if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
	var container;
	var camera, controls, scene, renderer;
	var time = 0;
	
	var circles;
	var arrows;

	var translateToCenter = new THREE.Matrix4().makeTranslation( -($scope.gridSize[0]-1)/2,-($scope.gridSize[1]-1)/2,-($scope.gridSize[2]-1)/2)


	init();
	



			
	function init( ) {
		container = document.getElementById("structure");
	
		camera = new THREE.PerspectiveCamera( 50, container.offsetWidth/container.offsetHeight, 0.01, 1e10 );  //distance , 
		camera.position.set( 10, 10, 10);		
		camera.up.set( 0, 0, 1 );
		camera.lookAt( 0,0, 0);

	
		controls = new THREE.TrackballControls( camera, container );
		controls.dynamicDampingFactor = 0.5;
		controls.rotateSpeed = 5;
		scene = new THREE.Scene();
		scene.add( camera );


		drawArrows();
		drawCircles();
		
		//$scope.spinStructure =  structure($scope.timeStep);
		//$scope.fftStructure = fftStructure($scope.spinStructure);
		processStructure();
		showStructure(arrows, $scope.spinStructure[0]);
		
		//requestAnimationFrame( animate )		
		

		renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize(container.offsetWidth, container.offsetHeight );
		renderer.setClearColor( 0xffffff, 1);
		container.appendChild( renderer.domElement );
		
		//controls = new THREE.OrbitControls( camera, renderer.domElement );
		
		// axes arrows
		arrow = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 5, 0xff0000, 0.5, 0.4);
		scene.add(arrow);
		arrow = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), 5, 0x00ff00, 0.5, 0.4);
		scene.add(arrow);
		arrow = new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,0), 5, 0x0000ff, 0.5, 0.4);
		scene.add(arrow);
	}
	

	
	function processStructure() {
		for (i = 0; i < $scope.delay.length; i++) { 
			$scope.spinStructure[i] =  structure(i*10);
			$scope.fftStructure[i] = fftStructure($scope.spinStructure[i]);
		}
	}

	
	
	function structure(timeStep){
		vectors = Array();
		for (z = 0; z < $scope.gridSize[2]; z++) { 
		for (y = 0; y < $scope.gridSize[1]; y++) { 
		for (x = 0; x < $scope.gridSize[0]; x++) { 
			
			// start with magnetisation pointing along z axis
			var v0 = new THREE.Vector3( 0, 0, 1 );
			
			// dynamics
			v0.applyAxisAngle( new THREE.Vector3( 1, 0, 0 ), Math.PI/180* $scope.hall );					// rotate about x by hall angle
			var phaseStep = 2*Math.PI*$scope.phasePeriods* x /$scope.gridSize[0] + timeStep/180*Math.PI;
			v0.applyAxisAngle( new THREE.Vector3( 0, 0, 1 ), phaseStep )									// rotate about z by precession angle
			
			
			v0.applyAxisAngle( new THREE.Vector3( 1, 0, 0 ), (90-$scope.zeeman)*Math.PI/180 )				// rotate by 90 degrees - zeeman about x axis
		
			// conical structure
			var conicalStep = 2*Math.PI*$scope.conicalPeriods * x /$scope.gridSize[0];
			v0.applyAxisAngle( new THREE.Vector3( 0, 0, 1), conicalStep )									// rotate about z axis by conical precession
			
			v0.applyAxisAngle( new THREE.Vector3( 0, 1, 0 ), ($scope.tilt * Math.PI / 180));				// rotate about x by tilt angle
			
			
			vectors = vectors.concat(v0);
		}}}
		return vectors
	}
	
	
	function fftStructure(vectors){
		var mag_u = vectors.map(function(m){ return m.x });
		var mag_v = vectors.map(function(m){ return m.y });
		var mag_w = vectors.map(function(m){ return m.z });
		
		var fft_u = cfft(mag_u);
		var fft_v = cfft(mag_v);
		var fft_w = cfft(mag_w);

		// fftshift
		var num = $scope.gridSize[0] / 2
		fft_u = fft_u.slice(num).concat(fft_u.slice(0,num));
		fft_v = fft_v.slice(num).concat(fft_v.slice(0,num));
		fft_w = fft_w.slice(num).concat(fft_w.slice(0,num));
		
		return [fft_u, fft_v, fft_w];
	}
		
		
	function circle(r, color){
		var lineGeometry = new THREE.Geometry();
		var vertArray = lineGeometry.vertices;
		for (var i=0; i < 2*Math.PI; i+=0.01) {
			vertArray.push(new THREE.Vector3(r * Math.cos(i), r * Math.sin(i), 0));
		}
		lineGeometry.computeLineDistances();
		var lineMaterial = new THREE.LineBasicMaterial({ color: color });
		var circle = new THREE.Line(lineGeometry, lineMaterial);

		return circle;
	}
		
	function drawCircles() {
		scene.remove(circles); 
		circles = new THREE.Group();

		for (z = 0; z < $scope.circlesGridSize[2]; z++) { 
		for (y = 0; y < $scope.circlesGridSize[1]; y++) { 
		for (x = 0; x < $scope.circlesGridSize[0]; x++) { 
			// static circles
			length = Math.cos(Math.PI/180*$scope.zeeman);
			circ = circle(length, 0xaaffaa);							// static circles in x-y plane
			translation = new THREE.Matrix4().makeTranslation(0,0, Math.sin(Math.PI/180*$scope.zeeman));
			circ.applyMatrix(translation);
			rotation = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 1, 0), ($scope.tilt * Math.PI / 180));
			circ.applyMatrix(rotation);									// rotate by tilt angles
			translation = new THREE.Matrix4().makeTranslation(x,y,z);	// translate to position of spin
			circ.applyMatrix(translation);
			circles.add( circ );
			
			// make dynamics red circle in x-y plane
			circ = circle(Math.sin(Math.PI/180* $scope.hall), 0xffaaaa);
			
			// translate circle to the end of the arrow
			length = Math.cos(Math.PI/180*$scope.hall);
			transformation = new THREE.Matrix4().makeTranslation(0,0, length);
			circ.applyMatrix(transformation);
			
			// now do the same transformations as we do to the arrow			
			//rotate by 90 degrees - zeeman angle about x axis
			rotation = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1, 0, 0), (90-$scope.zeeman) * Math.PI / 180);
			circ.applyMatrix(rotation);

			var conicalStep = 2*Math.PI*$scope.conicalPeriods*x/$scope.gridSize[0];
			rotation = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1),conicalStep);
			circ.applyMatrix(rotation);
			
			rotation = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 1, 0), ($scope.tilt * Math.PI / 180 ));
			circ.applyMatrix(rotation);
			
			
			transformation = new THREE.Matrix4().makeTranslation(x,y, z);
			circ.applyMatrix(transformation);					// translate to position of spin

			circles.add( circ );
		}}}
				
		circles.applyMatrix(translateToCenter);
		scene.add(circles);
	}
		
		
	function drawArrows(){
		arrows = new THREE.Group();
		for (z = 0; z < $scope.gridSize[2]; z++) { 
		for (y = 0; y < $scope.gridSize[1]; y++) { 
		for (x = 0; x < $scope.gridSize[0]; x++) { 
			var arrow = new THREE.ArrowHelper(new THREE.Vector3(0,0,0), new THREE.Vector3( x,y,z ), 1, 0xffffff, 0.5, 0.4);
			arrows.add(arrow);
		}}}
		
		arrows.applyMatrix(translateToCenter); // move to rotation center
		scene.add(arrows);
	}

	function showStructure(object, omf) {
		for (i = 0; i < arrows.children.length; i++ ) { 
			var color = new THREE.Color( 0x000000 );
			//var xy = new THREE.Vector2(omf[i*3],omf[i*3+1]);
			//var hue = Math.atan2(xy.y, xy.x)/(2*Math.PI);
			//color.setHSL(hue,1,0.5);
			
			arrows.children[i].setColor(color);
			arrows.children[i].setDirection(omf[i]);
		}
	}
	
	
	
		
	
		
	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
		controls.handleResize();
	}
	
	
	//function animate() {
	//console.log (object3D.rotation.x + " " + object3D.rotation.y + " " + object3D.rotation.z);
	//console.log (camera.position.x + " " + camera.position.y + " " + camera.position.z + " " + camera.rotation.x + " " + camera.rotation.y + " " + camera.rotation.z);
		//object3D.rotation.z += 0.001;
		//object3D.rotation.z += 0.01;
		
		// time step
	//	time = (time + $scope.speed) % 360;
		
	//	showStructure(arrows, structure());
		
		
		//requestAnimationFrame( animate );
	//	controls.update();
	//	renderer.render( scene, camera );
	//}
	
	
	
	function PS(laa) {
		//""" 
		//Poincare-Stokes representation of polarisation 
		//based on arbitary linear polarisation angle laa
		//https://en.wikipedia.org/wiki/Stokes_parameters
		//"""
		
		var chi = 0;
		var I = 1;
		var Ip = 1;
		
		var out = [];
		for (var i = 0; i < laa.length; i++) {
			var s0 = I; 
			var s1 = Ip * Math.cos(2*laa[i] * Math.PI/180 )* Math.cos(2*chi);
			var s2 = Ip * Math.sin(2*laa[i] * Math.PI/180) * Math.cos(2*chi);
			var s3 = Ip * Math.sin(2*chi);
			out[i] = [s0, s1, s2, s3];
		}
		return out;
	}
	

	
	function calculateLaaDelay(laa, delay, idx){
		var P = PS(laa);
		
		var laaDelayGrid = [];
		for (var j=0; j < delay.length; j++) {
			laaDelayGrid[j] = [];
			
			//var spinStructure =  structure(delay[j]);
			//var myfftStructure = fftStructure(spinStructure);
		
			for (var i=0; i < P.length; i++) {
				laaDelayGrid[j][i] = intensity(P[i], $scope.fftStructure[j], idx);
			}
		}
		
		// differentiate grid along delay 
		var laaDelayGridDiff = [];
		for (var j=0; j < delay.length; j++) {
			laaDelayGridDiff[j] = [];
			for (var i=0; i < P.length; i++) {
				if (j==0) {
					laaDelayGridDiff[j][i] = 0;
				} else {
					laaDelayGridDiff[j][i] = laaDelayGrid[j][i]  - laaDelayGrid[j-1][i];
				}
			}
		}
		
		return laaDelayGridDiff;
	}
	
	

	
	function intensity(P, fftStructure, idx){ //mag, P,ki,ks
		//"""
		//Scattered intensity from an input polarisation P and incident vector ki and output vector ks
		//From equation A6 in Zhang_PRB_2017
		//"""
		var F = 1;

		var MQ = new THREE.Vector3(fftStructure[0][idx], fftStructure[1][idx], fftStructure[2][idx]);		
		var MQconj = new THREE.Vector3(conjugate(fftStructure[0][idx]), conjugate(fftStructure[1][idx]), conjugate(fftStructure[2][idx]));
		
		out =       0.5*F**2 * (P[0] + P[1]) *  abs( dot($scope.ks, MQ) )**2;   
		out = out + 0.5*F**2 * (P[0] - P[1]) * (abs( dot($scope.ki, MQ) )**2  + abs( dot( $scope.ks.cross($scope.ki)  , MQ))**2);
		a = new Complex(P[2], P[3]);
		a = a.mul(dot( $scope.ks, MQconj ), a);
		a = a.mul( dot( $scope.ks.cross($scope.ki) , MQ), a);
		out = out -     F**2 * a['re'] ; 
		
		return out;
	}
	
	
	
	
	
});
</script>